{"pages":[{"url":"pages/jprobe.html","text":"有时候想知道下发某个操作后内核在做些什么，这个时候就要内内核进行调试， 然而KGDB这种方法操作起来相对麻烦，这个时候我们就可以使用kprobe/jprobe/kretprobe来窥视内核的行为。 介绍kprobe的文档为: https://www.kernel.org/doc/Documentation/kprobes.txt jprobe适合用来观察被探测函数的入参，kretprobe适合用来观察被探测函数的返回值，而kprobe则更加灵活。 下面举一个最简单的例子，介绍如何使用jprobe来查看 _do_fork 这个函数的调用情况。 /* * Here's a sample kernel module showing the use of jprobes to dump * the arguments of _do_fork(). * * For more information on theory of operation of jprobes, see * Documentation/kprobes.txt * * Build and insert the kernel module as done in the kprobe example. * You will see the trace data in /var/log/messages and on the * console whenever _do_fork() is invoked to create a new process. * (Some messages may be suppressed if syslogd is configured to * eliminate duplicate messages.) */ #include <linux/kernel.h> #include <linux/module.h> #include <linux/kprobes.h> /* * Jumper probe for _do_fork. * Mirror principle enables access to arguments of the probed routine * from the probe handler. */ /* Proxy routine having the same arguments as actual _do_fork() routine */ static long j_do_fork ( unsigned long clone_flags , unsigned long stack_start , unsigned long stack_size , int __user * parent_tidptr , int __user * child_tidptr , unsigned long tls ) { pr_info ( \"jprobe: clone_flags = 0x%lx, stack_start = 0x%lx \" \"stack_size = 0x%lx \\n \" , clone_flags , stack_start , stack_size ); /* Always end with a call to jprobe_return(). */ jprobe_return (); return 0 ; } static struct jprobe my_jprobe = { . entry = j_do_fork , . kp = { . symbol_name = \"_do_fork\" , }, }; static int __init jprobe_init ( void ) { int ret ; ret = register_jprobe ( & my_jprobe ); if ( ret < 0 ) { printk ( KERN_INFO \"register_jprobe failed, returned %d \\n \" , ret ); return - 1 ; } printk ( KERN_INFO \"Planted jprobe at %p, handler addr %p \\n \" , my_jprobe . kp . addr , my_jprobe . entry ); return 0 ; } static void __exit jprobe_exit ( void ) { unregister_jprobe ( & my_jprobe ); printk ( KERN_INFO \"jprobe at %p unregistered \\n \" , my_jprobe . kp . addr ); } module_init ( jprobe_init ) module_exit ( jprobe_exit ) MODULE_LICENSE ( \"GPL\" ); 使用下面的Makefile文件，对其进行编译。 obj-m := jprobe_example.o CROSS_COMPILE = '' KDIR := /lib/modules/ $( shell uname -r ) /build all : make -C $( KDIR ) M = $( PWD ) modules clean : rm -f *.ko *.o *.mod.o *.mod.c .*.cmd *.symvers modul* 编译完成后会生产一个名为 jprobe_example.ko 的内核模块文件，执行 insmod jprobe_example.ko 后内核模块立即生效，通过 dmesg 命令可以查看到 _do_fork 这个函数的调用情况。 [22995.253751] jprobe_example: loading out-of-tree module taints kernel. [22995.253784] jprobe_example: module verification failed: signature and/or required key missing - tainting kernel [22995.256380] Planted jprobe at ffffffff840a5740, handler addr ffffffffc0856000 [22995.257404] jprobe: clone_flags = 0x1200011, stack_start = 0x0 stack_size = 0x0 [22995.257589] jprobe: clone_flags = 0x1200011, stack_start = 0x0 stack_size = 0x0 [22995.257672] jprobe: clone_flags = 0x1200011, stack_start = 0x0 stack_size = 0x0 [22995.258624] jprobe: clone_flags = 0x1200011, stack_start = 0x0 stack_size = 0x0 [22995.258868] jprobe: clone_flags = 0x1200011, stack_start = 0x0 stack_size = 0x0 [22995.259052] jprobe: clone_flags = 0x1200011, stack_start = 0x0 stack_size = 0x0 [22997.501546] jprobe: clone_flags = 0x1200011, stack_start = 0x0 stack_size = 0x0 [22997.516927] jprobe: clone_flags = 0x1200011, stack_start = 0x0 stack_size = 0x0","tags":"pages","title":"jprobe example"}]}